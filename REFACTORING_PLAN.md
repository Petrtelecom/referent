# План рефакторинга структуры файлов

## Текущая структура

```
app/
  api/
    translate/route.ts
    ai-process/route.ts
    generate-image/route.ts
    check-api-key/route.ts
    parse/route.ts
    check-article/route.ts
  components/
    ui/alert.tsx
  page.tsx (1015 строк!)
  utils/
    error-handler.ts
```

## Предлагаемая новая структура

```
app/
  api/                          # API endpoints (остаются, но упрощаются)
    translate/route.ts
    ai-process/route.ts
    generate-image/route.ts
    check-api-key/route.ts
    parse/route.ts
    check-article/route.ts
  
  lib/                          # НОВАЯ: Бизнес-логика и сервисы
    providers/                  # НОВАЯ: Абстракция для AI провайдеров
      base-provider.ts
      openrouter-provider.ts
      proxyapi-provider.ts
      provider-factory.ts
    services/                   # НОВАЯ: Сервисы для бизнес-логики
      translation-service.ts
      ai-processing-service.ts
      image-generation-service.ts
      article-parser-service.ts
    config/                     # НОВАЯ: Конфигурация
      env-config.ts
      provider-config.ts
    utils/                       # НОВАЯ: Утилиты для API
      request-validator.ts
      response-formatter.ts
      text-truncator.ts
  
  components/                   # РАСШИРЯЕМ: Компоненты UI
    ui/
      alert.tsx
    features/                    # НОВАЯ: Компоненты по функциональности
      article-input/
        article-input.tsx
      action-buttons/
        action-buttons.tsx
      result-display/
        result-display.tsx
        image-result.tsx
      share-menu/
        share-menu.tsx
    hooks/                       # НОВАЯ: React хуки
      use-article-parser.ts
      use-translation.ts
      use-ai-processing.ts
      use-image-generation.ts
  
  utils/                         # ОСТАЕТСЯ: Общие утилиты
    error-handler.ts            # Расширяем
  
  page.tsx                      # УПРОЩАЕМ: Только композиция компонентов
```

---

## Детальное обоснование изменений

### 1. Создание `lib/providers/` - Абстракция для AI провайдеров

#### 1.1. `lib/providers/base-provider.ts`

**Зачем?**
- Устранить дублирование кода работы с AI API в 4 файлах (translate, ai-process, generate-image, check-api-key)
- Создать единый интерфейс для работы с разными провайдерами (OpenRouter, ProxyAPI)
- Упростить добавление новых провайдеров в будущем

**Что получаем:**
- ✅ Единая точка работы с AI API
- ✅ Легкое переключение между провайдерами
- ✅ Устранение ~200 строк дублированного кода
- ✅ Единая обработка ошибок для всех провайдеров
- ✅ Простое тестирование (можно мокировать провайдер)

**Что теряем:**
- ⚠️ Небольшое усложнение архитектуры (добавляется слой абстракции)
- ⚠️ Нужно время на миграцию существующего кода

**Описание структур, связей и процессов:**

```typescript
// Базовый интерфейс провайдера
interface AIProvider {
  chatCompletion(request: ChatRequest): Promise<ChatResponse>
  validateApiKey(): Promise<boolean>
}

// Структура:
// - base-provider.ts: абстрактный класс с общей логикой
// - openrouter-provider.ts: реализация для OpenRouter
// - proxyapi-provider.ts: реализация для ProxyAPI
// - provider-factory.ts: фабрика для создания нужного провайдера

// Процесс:
// 1. Фабрика читает конфигурацию из env
// 2. Создает нужный провайдер (OpenRouter/ProxyAPI)
// 3. Сервисы используют провайдер через единый интерфейс
// 4. Провайдер обрабатывает специфичные для него детали (URL, заголовки)
```

---

### 2. Создание `lib/services/` - Бизнес-логика

#### 2.1. `lib/services/translation-service.ts`

**Зачем?**
- Вынести бизнес-логику перевода из API роута
- Упростить тестирование (можно тестировать сервис отдельно от HTTP)
- Переиспользовать логику перевода в других местах (например, в компонентах)

**Что получаем:**
- ✅ Разделение ответственности: API роут = валидация + вызов сервиса
- ✅ Возможность переиспользования логики
- ✅ Упрощение тестирования
- ✅ Чистый код в API роутах (~50 строк вместо 200+)

**Что теряем:**
- ⚠️ Дополнительный слой вызовов (но это не критично для производительности)

**Описание структур, связей и процессов:**

```typescript
// Сервис инкапсулирует:
// - Валидацию входных данных
// - Обрезку текста при необходимости
// - Вызов провайдера через единый интерфейс
// - Обработку ответа и форматирование результата

// Связи:
// translation-service.ts -> providers/base-provider.ts
// api/translate/route.ts -> services/translation-service.ts

// Процесс:
// 1. API роут получает запрос
// 2. Валидирует базовые параметры (JSON, наличие text)
// 3. Вызывает translation-service.translate(text)
// 4. Сервис валидирует текст, обрезает при необходимости
// 5. Сервис получает провайдера из фабрики
// 6. Сервис вызывает провайдер.chatCompletion()
// 7. Сервис обрабатывает ответ и возвращает результат
```

---

#### 2.2. `lib/services/ai-processing-service.ts`

**Зачем?**
- Вынести логику AI-обработки (summary, theses, telegram-post) из API роута
- Централизовать управление промптами
- Упростить добавление новых типов обработки

**Что получаем:**
- ✅ Чистый API роут (~30 строк вместо 300+)
- ✅ Централизованное управление промптами
- ✅ Легкое добавление новых типов обработки
- ✅ Возможность переиспользования в других местах

**Что теряем:**
- ⚠️ Небольшое усложнение структуры

**Описание структур, связей и процессов:**

```typescript
// Сервис содержит:
// - getPromptForAction() - генерация промптов
// - processArticle() - основная логика обработки
// - Валидацию articleData
// - Обрезку контента при необходимости

// Связи:
// ai-processing-service.ts -> providers/base-provider.ts
// api/ai-process/route.ts -> services/ai-processing-service.ts

// Процесс:
// 1. API роут валидирует action и articleData
// 2. Вызывает ai-processing-service.process(action, articleData)
// 3. Сервис генерирует промпт для действия
// 4. Сервис получает провайдера и вызывает chatCompletion()
// 5. Сервис обрабатывает ответ и возвращает результат
```

---

#### 2.3. `lib/services/image-generation-service.ts`

**Зачем?**
- Вынести сложную логику генерации изображений из API роута
- Разделить ответственность: генерация промпта vs генерация изображения
- Упростить поддержку разных провайдеров изображений (Gemini, HuggingFace)

**Что получаем:**
- ✅ Чистый API роут
- ✅ Разделение логики промпта и генерации
- ✅ Легкое добавление новых провайдеров изображений
- ✅ Упрощение тестирования

**Что теряем:**
- ⚠️ Дополнительный слой абстракции

**Описание структур, связей и процессов:**

```typescript
// Сервис содержит:
// - generatePrompt() - генерация промпта через AI
// - generateImage() - генерация изображения через провайдер
// - Логику выбора провайдера (Gemini vs HuggingFace)

// Связи:
// image-generation-service.ts -> providers/base-provider.ts (для промпта)
// image-generation-service.ts -> providers/image-provider.ts (для изображения, если создадим)
// api/generate-image/route.ts -> services/image-generation-service.ts

// Процесс:
// 1. API роут валидирует articleData
// 2. Вызывает image-generation-service.generate(articleData)
// 3. Сервис генерирует промпт через AI провайдер
// 4. Сервис генерирует изображение через image провайдер
// 5. Сервис возвращает результат
```

---

#### 2.4. `lib/services/article-parser-service.ts`

**Зачем?**
- Вынести логику парсинга из API роута
- Переиспользовать парсинг в других местах (например, в компонентах)
- Упростить тестирование парсинга

**Что получаем:**
- ✅ Чистый API роут
- ✅ Переиспользование логики парсинга
- ✅ Упрощение тестирования

**Что теряем:**
- ⚠️ Небольшое усложнение структуры

**Описание структур, связей и процессов:**

```typescript
// Сервис содержит:
// - parseArticle() - основная логика парсинга
// - extractContent() - извлечение контента из HTML
// - detectLanguage() - определение языка

// Связи:
// article-parser-service.ts -> (использует cheerio)
// api/parse/route.ts -> services/article-parser-service.ts

// Процесс:
// 1. API роут валидирует URL
// 2. Вызывает article-parser-service.parse(url)
// 3. Сервис загружает HTML
// 4. Сервис парсит HTML и извлекает данные
// 5. Сервис возвращает структурированные данные
```

---

### 3. Создание `lib/config/` - Конфигурация

#### 3.1. `lib/config/env-config.ts`

**Зачем?**
- Централизовать чтение переменных окружения
- Валидировать конфигурацию при старте
- Предоставить типизированный доступ к конфигурации

**Что получаем:**
- ✅ Единая точка конфигурации
- ✅ Типизация конфигурации
- ✅ Валидация при старте (раннее обнаружение ошибок)
- ✅ Устранение дублирования чтения env переменных

**Что теряем:**
- ⚠️ Небольшое усложнение (но это оправдано)

**Описание структур, связей и процессов:**

```typescript
// Конфигурация содержит:
// - TRANSLATION_PROVIDER_URL
// - TRANSLATION_MODEL
// - TRANSLATION_API_KEY
// - IMAGE_PROVIDER_URL
// - IMAGE_MODEL
// - IMAGE_API_KEY
// - Значения по умолчанию

// Связи:
// Все сервисы и провайдеры -> config/env-config.ts

// Процесс:
// 1. При импорте config читает env переменные
// 2. Валидирует обязательные переменные
// 3. Применяет значения по умолчанию
// 4. Экспортирует типизированный объект конфигурации
```

---

#### 3.2. `lib/config/provider-config.ts`

**Зачем?**
- Определить, какой провайдер использовать на основе конфигурации
- Хранить настройки провайдеров (URL, модели, заголовки)
- Упростить добавление новых провайдеров

**Что получаем:**
- ✅ Централизованная конфигурация провайдеров
- ✅ Легкое переключение между провайдерами
- ✅ Устранение жестко закодированных URL

**Что теряем:**
- ⚠️ Небольшое усложнение

**Описание структур, связей и процессов:**

```typescript
// Конфигурация содержит:
// - Настройки для каждого провайдера
// - Логику определения провайдера по URL
// - Настройки заголовков для каждого провайдера

// Связи:
// provider-factory.ts -> provider-config.ts
// providers/*.ts -> provider-config.ts

// Процесс:
// 1. provider-config анализирует TRANSLATION_PROVIDER_URL
// 2. Определяет тип провайдера (OpenRouter/ProxyAPI)
// 3. Возвращает соответствующие настройки
// 4. Фабрика использует настройки для создания провайдера
```

---

### 4. Создание `lib/utils/` - Утилиты для API

#### 4.1. `lib/utils/request-validator.ts`

**Зачем?**
- Устранить дублирование валидации запросов во всех API роутах
- Централизовать правила валидации
- Упростить добавление новых правил

**Что получаем:**
- ✅ Устранение ~100 строк дублированного кода
- ✅ Единые правила валидации
- ✅ Легкое добавление новых правил

**Что теряем:**
- ⚠️ Небольшое усложнение (но это оправдано)

**Описание структур, связей и процессов:**

```typescript
// Утилита содержит:
// - validateJsonRequest() - валидация JSON запроса
// - validateText() - валидация текста
// - validateArticleData() - валидация данных статьи
// - validateAction() - валидация типа действия

// Связи:
// Все API роуты -> utils/request-validator.ts

// Процесс:
// 1. API роут получает запрос
// 2. Вызывает validator.validateJsonRequest(request)
// 3. Валидатор проверяет формат и возвращает ошибку или данные
// 4. API роут обрабатывает результат
```

---

#### 4.2. `lib/utils/response-formatter.ts`

**Зачем?**
- Стандартизировать формат ответов API
- Упростить форматирование ошибок
- Обеспечить единообразие ответов

**Что получаем:**
- ✅ Единый формат ответов
- ✅ Упрощение форматирования
- ✅ Устранение дублирования

**Что теряем:**
- ⚠️ Небольшое усложнение

**Описание структур, связей и процессов:**

```typescript
// Утилита содержит:
// - formatSuccess() - форматирование успешного ответа
// - formatError() - форматирование ошибки
// - formatTruncated() - форматирование с предупреждением об обрезке

// Связи:
// Все API роуты -> utils/response-formatter.ts

// Процесс:
// 1. Сервис возвращает результат
// 2. API роут вызывает formatter.formatSuccess(result)
// 3. Форматтер создает стандартизированный ответ
// 4. API роут возвращает ответ
```

---

#### 4.3. `lib/utils/text-truncator.ts`

**Зачем?**
- Устранить дублирование логики обрезки текста (есть в translate и ai-process)
- Централизовать правила обрезки
- Упростить изменение логики обрезки

**Что получаем:**
- ✅ Устранение ~30 строк дублированного кода
- ✅ Единая логика обрезки
- ✅ Легкое изменение правил обрезки

**Что теряем:**
- ⚠️ Небольшое усложнение

**Описание структур, связей и процессов:**

```typescript
// Утилита содержит:
// - truncateText() - обрезка текста с учетом лимитов
// - truncateBySentence() - обрезка по предложениям
// - Логику определения места обрезки

// Связи:
// translation-service.ts -> utils/text-truncator.ts
// ai-processing-service.ts -> utils/text-truncator.ts

// Процесс:
// 1. Сервис получает текст
// 2. Вызывает truncator.truncateText(text, maxLength)
// 3. Утилита обрезает текст и возвращает результат + флаг обрезки
// 4. Сервис использует результат
```

---

### 5. Расширение `components/` - Разбиение page.tsx

#### 5.1. `components/features/article-input/article-input.tsx`

**Зачем?**
- Вынести логику ввода URL из page.tsx
- Создать переиспользуемый компонент
- Упростить page.tsx (~100 строк вместо 1015)

**Что получаем:**
- ✅ Переиспользуемый компонент
- ✅ Упрощение page.tsx
- ✅ Легкое тестирование компонента отдельно

**Что теряем:**
- ⚠️ Небольшое усложнение структуры (но это оправдано)

**Описание структур, связей и процессов:**

```typescript
// Компонент содержит:
// - Поле ввода URL
// - Кнопку очистки
// - Валидацию URL
// - Обработку изменений

// Связи:
// page.tsx -> components/features/article-input/article-input.tsx

// Процесс:
// 1. Компонент отображает поле ввода
// 2. При изменении вызывает onChange(url)
// 3. page.tsx обрабатывает изменение
```

---

#### 5.2. `components/features/action-buttons/action-buttons.tsx`

**Зачем?**
- Вынести кнопки действий из page.tsx
- Создать переиспользуемый компонент
- Упростить page.tsx

**Что получаем:**
- ✅ Переиспользуемый компонент
- ✅ Упрощение page.tsx
- ✅ Легкое добавление новых кнопок

**Что теряем:**
- ⚠️ Небольшое усложнение структуры

**Описание структур, связей и процессов:**

```typescript
// Компонент содержит:
// - Кнопки действий (Перевести, О чем статья?, и т.д.)
// - Состояние активной кнопки
// - Обработчики кликов

// Связи:
// page.tsx -> components/features/action-buttons/action-buttons.tsx

// Процесс:
// 1. Компонент отображает кнопки
// 2. При клике вызывает onAction(action)
// 3. page.tsx обрабатывает действие
```

---

#### 5.3. `components/features/result-display/result-display.tsx`

**Зачем?**
- Вынести логику отображения результатов из page.tsx
- Создать переиспользуемый компонент
- Упростить page.tsx

**Что получаем:**
- ✅ Переиспользуемый компонент
- ✅ Упрощение page.tsx
- ✅ Легкое изменение отображения

**Что теряем:**
- ⚠️ Небольшое усложнение структуры

**Описание структур, связей и процессов:**

```typescript
// Компонент содержит:
// - Отображение текстового результата
// - Отображение изображения
// - Кнопки действий (копировать, сохранить, поделиться)

// Связи:
// page.tsx -> components/features/result-display/result-display.tsx
// result-display.tsx -> image-result.tsx (для изображений)

// Процесс:
// 1. Компонент получает результат через props
// 2. Отображает результат в зависимости от типа
// 3. Обрабатывает действия пользователя
```

---

#### 5.4. `components/hooks/` - React хуки

**Зачем?**
- Вынести логику работы с API из page.tsx в хуки
- Создать переиспользуемую логику
- Упростить page.tsx до композиции компонентов

**Что получаем:**
- ✅ Переиспользуемая логика
- ✅ Упрощение page.tsx
- ✅ Легкое тестирование логики отдельно

**Что теряем:**
- ⚠️ Небольшое усложнение структуры

**Описание структур, связей и процессов:**

```typescript
// Хуки содержат:
// - use-article-parser.ts: логика парсинга статьи
// - use-translation.ts: логика перевода
// - use-ai-processing.ts: логика AI-обработки
// - use-image-generation.ts: логика генерации изображений

// Связи:
// page.tsx -> hooks/use-*.ts
// hooks/use-*.ts -> api/*/route.ts

// Процесс:
// 1. Хук инкапсулирует состояние и логику
// 2. Возвращает функции и состояние
// 3. page.tsx использует хук
// 4. Компоненты используют данные из хука
```

---

## Итоговая структура

```
app/
  api/                          # API endpoints (упрощенные)
    translate/route.ts           # ~30 строк (было 200+)
    ai-process/route.ts         # ~30 строк (было 300+)
    generate-image/route.ts     # ~30 строк (было 500+)
    check-api-key/route.ts       # ~20 строк (было 80+)
    parse/route.ts               # ~30 строк (было 300+)
    check-article/route.ts       # ~20 строк
  
  lib/                          # Бизнес-логика
    providers/                   # Абстракция провайдеров
      base-provider.ts
      openrouter-provider.ts
      proxyapi-provider.ts
      provider-factory.ts
    services/                    # Сервисы
      translation-service.ts
      ai-processing-service.ts
      image-generation-service.ts
      article-parser-service.ts
    config/                      # Конфигурация
      env-config.ts
      provider-config.ts
    utils/                       # Утилиты
      request-validator.ts
      response-formatter.ts
      text-truncator.ts
  
  components/                    # Компоненты
    ui/
      alert.tsx
    features/
      article-input/
        article-input.tsx
      action-buttons/
        action-buttons.tsx
      result-display/
        result-display.tsx
        image-result.tsx
      share-menu/
        share-menu.tsx
    hooks/                       # React хуки
      use-article-parser.ts
      use-translation.ts
      use-ai-processing.ts
      use-image-generation.ts
  
  utils/                         # Общие утилиты
    error-handler.ts
  
  page.tsx                      # ~100 строк (было 1015)
```

---

## Преимущества новой структуры

1. **Устранение дублирования**: ~500 строк дублированного кода вынесены в переиспользуемые модули
2. **Разделение ответственности**: каждый модуль отвечает за свою область
3. **Упрощение тестирования**: можно тестировать каждый модуль отдельно
4. **Легкое расширение**: легко добавлять новые провайдеры, сервисы, компоненты
5. **Читаемость**: код становится более понятным и структурированным
6. **Поддерживаемость**: изменения в одном месте не требуют изменений в других

---

## План миграции

1. **Этап 1**: Создать структуру папок и базовые интерфейсы
2. **Этап 2**: Реализовать провайдеры и конфигурацию
3. **Этап 3**: Реализовать сервисы
4. **Этап 4**: Реализовать утилиты
5. **Этап 5**: Рефакторинг API роутов
6. **Этап 6**: Разбиение page.tsx на компоненты и хуки
7. **Этап 7**: Тестирование и исправление ошибок

